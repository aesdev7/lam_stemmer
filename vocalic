# This is for __init__.py

"""
1.	Preliminaries.
A.	As principally conceived, the RULE of grammar was to be built from a Structural Description delimiting a class of inputs and a Structural Change specifying the operations that altered the input Explicating the system of predicates used to analyze inputs; the possible structural descriptions of rules, and to define the operations available for transforming inputs, the possible Structural Changes of rules.
B.	In dispute still, is the character of well-formedness constraints interaction, the relation between such constraints and whatever derivational rules they are meant to influence.  Indeed, this our impedes understanding the basic functioning of the grammar. The key point to underscore here is the role of well-formedness constraints as involving a kind of conceptual crisis at the center of phonological thought. Indeed, any serious theory of phonology must rely heavily on well-formedness constraints; where serious means commitment to Universal Grammar. 

2.	The Task:

A.	To explicate the system of predicates used to analyze inputs in Classical Arabic; the possible Structural Descriptions of rules, and to define the operations available for transforming inputs; the possible Structural Changes of rules.
B.	To establish a class of possible phonetic representation of Classical Arabic sentences by determining the universal set of phonetic features and the conditions on possible phonetic representation possible combinations.
C.	The role of the representational well-formedness determines the assignment of grammatical structure, the character of the interaction among the posited well-formedness constraints, as well as the relation between such constraints and whatever derivational rules they are meant to influence.

The Function proceeds as following:
-	Multiply Arabic consonants alphabet 28 * 28. A total of 784 single segments results from the multiplication. The result violates the Minimal-Root\Triplicity constraints (forthcoming) i.e. a single segment dose not compose a verb root in Arabic.
-	Orthographically speaking, bilateral root verbs build is in order. Phonologically, this type of roots does not violate Triplicity constraints (Idgam). The task is accomplished by pairing segments resulting in a total combination of 392 pairs of orderly unique bilateral verbs. Furthermore, for each single pair, do make a reversed pair; hence, one unique orderly pair and one unique reversed pair. Mathematically, 392*392= 784.

-	At this point, a few statistics are in order. Do print the count of: strong bilateral roots (a root composed of two consonants i.e. no vowel). Do the same for weak roots( a consonant and a vowel). The count of pairs composed of identical segments e.g.  "د د". The count of pairs composed of two vowels.


"""





#          This is based on Al Suti formulla in Almuzhir
#           A function to Generate all possible two-character combinations of the Arabic alphabet.
# Here is the explaination 

from itertools import product

def generate_arabic_combinations():
    """
    Generate all possible two-character combinations of the Arabic alphabet, including both
    the normal order and the reversed order of each pair. The Arabic alphabet contains 28
    letters, resulting in 784 total combinations (392 unique pairs, each counted twice).

    Returns:
        list: A list of 784 strings, each representing a two-character combination.
    """
    # Step 1: Define the Arabic alphabet
    arabic_alphabet = [
        "ا", "ب", "ت", "ث", "ج", "ح", "خ", "د", "ذ", "ر",
        "ز", "س", "ش", "ص", "ض", "ط", "ظ", "ع", "غ", "ف",
        "ق", "ك", "ل", "م", "ن", "ه", "و", "ي"
    ]

    # Step 2: Create all combinations of the alphabet with itself (28 * 28)
    combinations = list(product(arabic_alphabet, repeat=2))

    # Step 3: Keep all 392 unique combinations
    unique_combinations = ["".join(combo) for combo in combinations]

    # Step 4: Multiply the 392 unique combinations by 2 to include both normal and reversed pairs
    final_combinations = []
    for pair in unique_combinations:
        final_combinations.append(pair)        # Normal pair
        final_combinations.append(pair[::-1])  # Reversed pair

    # Step 5: Return the final list of combinations
    return final_combinations

# Example usage
combinations = generate_arabic_combinations()
print(f"Total combinations: {len(combinations)}")
print(combinations)  # Print all combinations

